'use strict';let inflectionCount=0,synonymCount=0,inflectionCharCount=0,synonymCharCount=0,contentCharCount=0,regex,synonyms,inflections;const reset=()=>{inflectionCount=0,synonymCount=0,inflectionCharCount=0,synonymCharCount=0,contentCharCount=0,regex=void 0,synonyms=void 0,inflections=void 0},normalizeSpacing=c=>c.replace(/(?!(\n+|\r)+)(&nbsp;|\s)+/gu,' '),escapeRegex=c=>c.replace(/[\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,'\\$&'),bewilderRegexNonWords=c=>c.replace(/\W+/gu,'\\W+'),escapeStr=(c,d)=>{return c.length?d?c.replace(/[&<>]/g,f=>{return{'&':'&amp;','<':'&lt;','>':'&gt;'}[f]}):c.replace(/[&<>"']/g,f=>{return{'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[f]}):''},promiseLoop=(c,d,f=0,g=2e3)=>new Promise((h,j)=>{let k=c.length;if(!k)return h();const l=n=>{let o,p,q;g&&(p=setTimeout(()=>{clearTimeout(o),q=setTimeout(()=>{j()},250)},g)),o=setTimeout(()=>{return new Promise((r,s)=>{try{d(c[n]),r()}catch(t){s()}}).then(()=>{if(g&&(clearTimeout(p),q)){if(n<k)return;clearTimeout(q)}++n===k?h():(o=null,l(n))}).catch(()=>{j()})},f)};l(0)}),countChars=c=>{return c=c.match(/(?=([^<>]+))\1(?=<|$)/gi),c&&c.join('').length||0},countWords=(c,d)=>{let f,g=bewilderRegexNonWords(escapeRegex(escapeStr(c,!0)));for(let h=0;h<regex.length&&(f=/\/(.*)\/(.*)/.exec(regex[h]),d=d.match(new RegExp(f[1].replace(/\{\{kw\}\}/g,g),f[2])),d&&h!==regex.length-1);h++)d=d.join(' ');return d&&d.length||0},stripWord=(c,d)=>d.replace(new RegExp(escapeRegex(escapeStr(c,!0)),'gi'),'/'),countCharacters=c=>new Promise(d=>{setTimeout(()=>{contentCharCount+=countChars(c),d()},5)}),countInflections=c=>{let d=inflections,f=c;return d.length&&d.sort((g,h)=>h.length-g.length),promiseLoop(d,g=>{let h=countWords(g,f);inflectionCount+=h,inflectionCharCount+=g.length*h,f=stripWord(g,f)},5,1e4)},countSynonyms=c=>{let d=synonyms,f=c;return d.length&&d.sort((g,h)=>h.length-g.length),promiseLoop(d,g=>{let h=countWords(g,f);synonymCount+=h,synonymCharCount+=g.length*h,f=stripWord(g,f)},5,1e4)};onmessage=c=>{reset();let d=c.data;content=normalizeSpacing(d.content),regex=d.regex,inflections=d.inflections,synonyms=d.synonyms,content?Promise.all([countCharacters(content),countInflections(content),countSynonyms(content)]).then(()=>{postMessage({inflectionCount,synonymCount,inflectionCharCount,synonymCharCount,contentCharCount})}).catch(f=>{postMessage({error:f})}):postMessage(void 0)},onerror=(c,d,f,g,h)=>{postMessage({error:h})};
